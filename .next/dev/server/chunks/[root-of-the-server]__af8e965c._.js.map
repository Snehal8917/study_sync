{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 52, "column": 0}, "map": {"version":3,"sources":["file:///Users/snehalprajapati/Desktop/AGILE/study-sync-app-build/lib/jwt.ts"],"sourcesContent":["import crypto from \"crypto\"\n\nconst SECRET = process.env.JWT_SECRET || \"study-sync-secret-key-change-in-production\"\n\ninterface JWTPayload {\n  id: string\n  email: string\n  name: string\n  iat?: number\n  exp?: number\n}\n\nexport function generateToken(payload: JWTPayload): string {\n  const header = Buffer.from(JSON.stringify({ alg: \"HS256\", typ: \"JWT\" })).toString(\"base64url\")\n\n  const now = Math.floor(Date.now() / 1000)\n  const tokenPayload = {\n    ...payload,\n    iat: now,\n    exp: now + 7 * 24 * 60 * 60,\n  }\n\n  const body = Buffer.from(JSON.stringify(tokenPayload)).toString(\"base64url\")\n  const signature = crypto.createHmac(\"sha256\", SECRET).update(`${header}.${body}`).digest(\"base64url\")\n\n  return `${header}.${body}.${signature}`\n}\n\nexport function verifyToken(token: string): JWTPayload | null {\n  try {\n    const [header, body, signature] = token.split(\".\")\n    const expectedSignature = crypto.createHmac(\"sha256\", SECRET).update(`${header}.${body}`).digest(\"base64url\")\n\n    if (signature !== expectedSignature) {\n      return null\n    }\n\n    const payload = JSON.parse(Buffer.from(body, \"base64url\").toString())\n\n    if (payload.exp && payload.exp < Math.floor(Date.now() / 1000)) {\n      return null\n    }\n\n    return payload\n  } catch (error) {\n    return null\n  }\n}\n"],"names":[],"mappings":";;;;;;AAAA;;AAEA,MAAM,SAAS,QAAQ,GAAG,CAAC,UAAU,IAAI;AAUlC,SAAS,cAAc,OAAmB;IAC/C,MAAM,SAAS,OAAO,IAAI,CAAC,KAAK,SAAS,CAAC;QAAE,KAAK;QAAS,KAAK;IAAM,IAAI,QAAQ,CAAC;IAElF,MAAM,MAAM,KAAK,KAAK,CAAC,KAAK,GAAG,KAAK;IACpC,MAAM,eAAe;QACnB,GAAG,OAAO;QACV,KAAK;QACL,KAAK,MAAM,IAAI,KAAK,KAAK;IAC3B;IAEA,MAAM,OAAO,OAAO,IAAI,CAAC,KAAK,SAAS,CAAC,eAAe,QAAQ,CAAC;IAChE,MAAM,YAAY,gHAAM,CAAC,UAAU,CAAC,UAAU,QAAQ,MAAM,CAAC,GAAG,OAAO,CAAC,EAAE,MAAM,EAAE,MAAM,CAAC;IAEzF,OAAO,GAAG,OAAO,CAAC,EAAE,KAAK,CAAC,EAAE,WAAW;AACzC;AAEO,SAAS,YAAY,KAAa;IACvC,IAAI;QACF,MAAM,CAAC,QAAQ,MAAM,UAAU,GAAG,MAAM,KAAK,CAAC;QAC9C,MAAM,oBAAoB,gHAAM,CAAC,UAAU,CAAC,UAAU,QAAQ,MAAM,CAAC,GAAG,OAAO,CAAC,EAAE,MAAM,EAAE,MAAM,CAAC;QAEjG,IAAI,cAAc,mBAAmB;YACnC,OAAO;QACT;QAEA,MAAM,UAAU,KAAK,KAAK,CAAC,OAAO,IAAI,CAAC,MAAM,aAAa,QAAQ;QAElE,IAAI,QAAQ,GAAG,IAAI,QAAQ,GAAG,GAAG,KAAK,KAAK,CAAC,KAAK,GAAG,KAAK,OAAO;YAC9D,OAAO;QACT;QAEA,OAAO;IACT,EAAE,OAAO,OAAO;QACd,OAAO;IACT;AACF"}},
    {"offset": {"line": 108, "column": 0}, "map": {"version":3,"sources":["file:///Users/snehalprajapati/Desktop/AGILE/study-sync-app-build/lib/fs.ts"],"sourcesContent":["import { promises as fs } from \"fs\"\nimport path from \"path\"\n\nconst DATA_DIR = path.join(process.cwd(), \"data\")\n\nexport async function readJSON(filename: string) {\n  try {\n    const filePath = path.join(DATA_DIR, filename)\n    const data = await fs.readFile(filePath, \"utf-8\")\n    return JSON.parse(data)\n  } catch (error) {\n    return []\n  }\n}\n\nexport async function writeJSON(filename: string, data: any) {\n  try {\n    const filePath = path.join(DATA_DIR, filename)\n    await fs.mkdir(DATA_DIR, { recursive: true })\n    await fs.writeFile(filePath, JSON.stringify(data, null, 2))\n  } catch (error) {\n    console.error(`Error writing to ${filename}:`, error)\n  }\n}\n\nexport function generateId() {\n  return `${Date.now()}_${Math.random().toString(36).substr(2, 9)}`\n}\n"],"names":[],"mappings":";;;;;;;;AAAA;AACA;;;AAEA,MAAM,WAAW,4GAAI,CAAC,IAAI,CAAC,QAAQ,GAAG,IAAI;AAEnC,eAAe,SAAS,QAAgB;IAC7C,IAAI;QACF,MAAM,WAAW,4GAAI,CAAC,IAAI,CAAC,UAAU;QACrC,MAAM,OAAO,MAAM,yGAAE,CAAC,QAAQ,CAAC,UAAU;QACzC,OAAO,KAAK,KAAK,CAAC;IACpB,EAAE,OAAO,OAAO;QACd,OAAO,EAAE;IACX;AACF;AAEO,eAAe,UAAU,QAAgB,EAAE,IAAS;IACzD,IAAI;QACF,MAAM,WAAW,4GAAI,CAAC,IAAI,CAAC,UAAU;QACrC,MAAM,yGAAE,CAAC,KAAK,CAAC,UAAU;YAAE,WAAW;QAAK;QAC3C,MAAM,yGAAE,CAAC,SAAS,CAAC,UAAU,KAAK,SAAS,CAAC,MAAM,MAAM;IAC1D,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,CAAC,iBAAiB,EAAE,SAAS,CAAC,CAAC,EAAE;IACjD;AACF;AAEO,SAAS;IACd,OAAO,GAAG,KAAK,GAAG,GAAG,CAAC,EAAE,KAAK,MAAM,GAAG,QAAQ,CAAC,IAAI,MAAM,CAAC,GAAG,IAAI;AACnE"}},
    {"offset": {"line": 148, "column": 0}, "map": {"version":3,"sources":["file:///Users/snehalprajapati/Desktop/AGILE/study-sync-app-build/app/api/streak/check-in/route.ts"],"sourcesContent":["import { type NextRequest, NextResponse } from \"next/server\"\nimport { verifyToken } from \"@/lib/jwt\"\nimport { readJSON, writeJSON } from \"@/lib/fs\"\n\nexport async function POST(request: NextRequest) {\n  try {\n    const token = request.headers.get(\"authorization\")?.replace(\"Bearer \", \"\")\n    if (!token) return NextResponse.json({ error: \"Unauthorized\" }, { status: 401 })\n\n    const payload = verifyToken(token)\n    if (!payload) return NextResponse.json({ error: \"Invalid token\" }, { status: 401 })\n\n    const streaks = await readJSON(\"streak.json\")\n    const userStreakIndex = streaks.findIndex((s: any) => s.userId === payload.id)\n\n    const today = new Date().toISOString().split(\"T\")[0]\n    let userStreak = userStreakIndex >= 0 ? streaks[userStreakIndex] : null\n\n    if (!userStreak) {\n      userStreak = {\n        userId: payload.id,\n        streak: 1,\n        lastCheckIn: today,\n        badges: [],\n      }\n      streaks.push(userStreak)\n    } else {\n      const lastCheckIn = userStreak.lastCheckIn\n      const lastDate = new Date(lastCheckIn)\n      const currentDate = new Date(today)\n      const daysDiff = Math.floor((currentDate.getTime() - lastDate.getTime()) / (1000 * 60 * 60 * 24))\n\n      if (daysDiff === 0) {\n        return NextResponse.json({ message: \"Already checked in today\" }, { status: 200 })\n      } else if (daysDiff === 1) {\n        userStreak.streak += 1\n      } else {\n        userStreak.streak = 1\n      }\n\n      userStreak.lastCheckIn = today\n\n      // Award badges\n      const badgeMilestones = [3, 7, 14, 30]\n      badgeMilestones.forEach((milestone) => {\n        if (userStreak.streak === milestone && !userStreak.badges.includes(milestone)) {\n          userStreak.badges.push(milestone)\n        }\n      })\n\n      streaks[userStreakIndex] = userStreak\n    }\n\n    await writeJSON(\"streak.json\", streaks)\n    return NextResponse.json(userStreak, { status: 200 })\n  } catch (error: any) {\n    return NextResponse.json({ error: error.message }, { status: 400 })\n  }\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;;;;AAEO,eAAe,KAAK,OAAoB;IAC7C,IAAI;QACF,MAAM,QAAQ,QAAQ,OAAO,CAAC,GAAG,CAAC,kBAAkB,QAAQ,WAAW;QACvE,IAAI,CAAC,OAAO,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,OAAO;QAAe,GAAG;YAAE,QAAQ;QAAI;QAE9E,MAAM,UAAU,IAAA,2HAAW,EAAC;QAC5B,IAAI,CAAC,SAAS,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,OAAO;QAAgB,GAAG;YAAE,QAAQ;QAAI;QAEjF,MAAM,UAAU,MAAM,IAAA,uHAAQ,EAAC;QAC/B,MAAM,kBAAkB,QAAQ,SAAS,CAAC,CAAC,IAAW,EAAE,MAAM,KAAK,QAAQ,EAAE;QAE7E,MAAM,QAAQ,IAAI,OAAO,WAAW,GAAG,KAAK,CAAC,IAAI,CAAC,EAAE;QACpD,IAAI,aAAa,mBAAmB,IAAI,OAAO,CAAC,gBAAgB,GAAG;QAEnE,IAAI,CAAC,YAAY;YACf,aAAa;gBACX,QAAQ,QAAQ,EAAE;gBAClB,QAAQ;gBACR,aAAa;gBACb,QAAQ,EAAE;YACZ;YACA,QAAQ,IAAI,CAAC;QACf,OAAO;YACL,MAAM,cAAc,WAAW,WAAW;YAC1C,MAAM,WAAW,IAAI,KAAK;YAC1B,MAAM,cAAc,IAAI,KAAK;YAC7B,MAAM,WAAW,KAAK,KAAK,CAAC,CAAC,YAAY,OAAO,KAAK,SAAS,OAAO,EAAE,IAAI,CAAC,OAAO,KAAK,KAAK,EAAE;YAE/F,IAAI,aAAa,GAAG;gBAClB,OAAO,gJAAY,CAAC,IAAI,CAAC;oBAAE,SAAS;gBAA2B,GAAG;oBAAE,QAAQ;gBAAI;YAClF,OAAO,IAAI,aAAa,GAAG;gBACzB,WAAW,MAAM,IAAI;YACvB,OAAO;gBACL,WAAW,MAAM,GAAG;YACtB;YAEA,WAAW,WAAW,GAAG;YAEzB,eAAe;YACf,MAAM,kBAAkB;gBAAC;gBAAG;gBAAG;gBAAI;aAAG;YACtC,gBAAgB,OAAO,CAAC,CAAC;gBACvB,IAAI,WAAW,MAAM,KAAK,aAAa,CAAC,WAAW,MAAM,CAAC,QAAQ,CAAC,YAAY;oBAC7E,WAAW,MAAM,CAAC,IAAI,CAAC;gBACzB;YACF;YAEA,OAAO,CAAC,gBAAgB,GAAG;QAC7B;QAEA,MAAM,IAAA,wHAAS,EAAC,eAAe;QAC/B,OAAO,gJAAY,CAAC,IAAI,CAAC,YAAY;YAAE,QAAQ;QAAI;IACrD,EAAE,OAAO,OAAY;QACnB,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,OAAO,MAAM,OAAO;QAAC,GAAG;YAAE,QAAQ;QAAI;IACnE;AACF"}}]
}